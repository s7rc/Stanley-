name: Email Checker Workflows

on:
  workflow_dispatch:
    inputs:
      script_type:
        description: 'Which script to run?'
        required: true
        type: choice
        options:
          - 'Hotmail Checker (Fast API)'
          - 'Selenium Checker (Browser)'
        default: 'Hotmail Checker (Fast API)'
      
      # Email Source Options
      email_source:
        description: 'Email source'
        required: true
        type: choice
        options:
          - 'Use emails.txt from repo'
          - 'Download from URL'
          - 'Download from GoFile'
        default: 'Use emails.txt from repo'
      
      email_url:
        description: 'URL to download emails.txt from (if "Download from URL" selected)'
        required: false
        type: string
        default: ''
      
      gofile_url:
        description: 'GoFile URL (if "Download from GoFile" selected) - e.g., https://gofile.io/d/abc123'
        required: false
        type: string
        default: ''
      
      gofile_password:
        description: 'GoFile password (if required)'
        required: false
        type: string
        default: ''
      
      # Common Options
      keyword:
        description: 'Keyword for output filenames (optional)'
        required: false
        type: string
        default: ''
      
      threads:
        description: 'Number of threads (Hotmail) or browsers (Selenium)'
        required: false
        type: number
        default: 200
      
      filter_emails:
        description: 'Filter for @hotmail.com only?'
        required: false
        type: boolean
        default: false
      
      enable_gofile:
        description: 'Enable GoFile auto-backup?'
        required: false
        type: boolean
        default: true
      
      backup_interval:
        description: 'Backup interval in hours'
        required: false
        type: number
        default: 1.0
      
      # Selenium Specific Options
      selenium_url:
        description: '[Selenium] Target URL (default: Microsoft signup)'
        required: false
        type: string
        default: 'https://signup.live.com/signup'
      
      headless_mode:
        description: '[Selenium] Run browser in headless mode?'
        required: false
        type: boolean
        default: true
      
      max_retries:
        description: '[Selenium] Max retries per email'
        required: false
        type: number
        default: 2

jobs:
  run-hotmail-checker:
    if: inputs.script_type == 'Hotmail Checker (Fast API)'
    runs-on: windows-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      
      - name: Install dependencies
        run: |
          pip install requests termcolor urllib3 requests-toolbelt
      
      - name: Setup emails.txt
        run: |
          if [ "${{ inputs.email_source }}" = "Download from URL" ]; then
            if [ -z "${{ inputs.email_url }}" ]; then
              echo "ERROR: Email URL is required when 'Download from URL' is selected!"
              exit 1
            fi
            echo "Downloading emails.txt from: ${{ inputs.email_url }}"
            curl -L -o emails.txt "${{ inputs.email_url }}"
            if [ $? -ne 0 ]; then
              echo "ERROR: Failed to download emails.txt from URL!"
              exit 1
            fi
            echo "Successfully downloaded emails.txt"
          elif [ "${{ inputs.email_source }}" = "Download from GoFile" ]; then
            if [ -z "${{ inputs.gofile_url }}" ]; then
              echo "ERROR: GoFile URL is required when 'Download from GoFile' is selected!"
              exit 1
            fi
            echo "Downloading emails.txt from GoFile: ${{ inputs.gofile_url }}"
            
            # Create inline GoFile downloader
            python3 - "${{ inputs.gofile_url }}" "${{ inputs.gofile_password }}" << 'GOFILE_SCRIPT'
          from os import getcwd, makedirs, path
          from sys import exit, stdout, stderr, argv
          from requests import Session, Response, Timeout
          from typing import Any, TextIO, NoReturn
          from shutil import move
          
          def _print(msg: str) -> None:
              stdout.write(msg)
              stdout.flush()
          
          class GoFileDownloader:
              def __init__(self, url: str, password: str = ""):
                  self._session = Session()
                  self._headers = {"User-Agent": "Mozilla/5.0", "Accept": "*/*"}
                  self._url = url
                  self._password = password
                  
              def _get_response(self, **kwargs):
                  for _ in range(3):
                      try:
                          return self._session.get(timeout=15, **kwargs)
                      except:
                          continue
              
              def _set_token(self):
                  try:
                      resp = self._session.post("https://api.gofile.io/accounts", headers=self._headers, timeout=15).json()
                      token = resp['data']['token']
                      self._headers["Cookie"] = f"accountToken={token}"
                      self._headers["Authorization"] = f"Bearer {token}"
                  except:
                      exit(1)
              
              def _download_file(self, url: str, filepath: str):
                  resp = self._get_response(url=url, headers=self._headers, stream=True)
                  if resp:
                      with open(filepath, 'wb') as f:
                          for chunk in resp.iter_content(8192):
                              f.write(chunk)
                      _print(f"Downloaded: {filepath}\n")
              
              def _fetch_content(self, parent_dir: str, content_id: str):
                  url = f"https://api.gofile.io/contents/{content_id}?wt=4fd6sg89d7s6&cache=true"
                  if self._password:
                      from hashlib import sha256
                      url += f"&password={sha256(self._password.encode()).hexdigest()}"
                  
                  resp = self._get_response(url=url, headers=self._headers)
                  if not resp:
                      exit(1)
                  
                  data = resp.json()["data"]
                  
                  if data["type"] != "folder":
                      self._download_file(data["link"], path.join(parent_dir, data["name"]))
                      return
                  
                  folder = path.join(parent_dir, data["name"]) if path.basename(parent_dir) != content_id else parent_dir
                  makedirs(folder, exist_ok=True)
                  
                  for child in data["children"].values():
                      if child["type"] == "folder":
                          self._fetch_content(folder, child["id"])
                      else:
                          self._download_file(child["link"], path.join(folder, child["name"]))
              
              def run(self):
                  content_id = self._url.split("/")[-1]
                  _print("Downloading from GoFile...\n")
                  self._set_token()
                  self._fetch_content(getcwd(), content_id)
                  _print("Complete!\n")
          
          if __name__ == "__main__":
              GoFileDownloader(argv[1], argv[2] if len(argv) > 2 and argv[2] else "").run()
          GOFILE_SCRIPT
            
            # Find the downloaded file
            CONTENT_ID=$(echo "${{ inputs.gofile_url }}" | awk -F'/' '{print $NF}')
            FOUND_FILE=$(find "$CONTENT_ID" -name "emails.txt" -o -name "*.txt" 2>/dev/null | head -n 1)
            
            if [ -z "$FOUND_FILE" ]; then
              echo "ERROR: Could not find emails.txt in downloaded GoFile content!"
              ls -la "$CONTENT_ID" 2>/dev/null || echo "Content directory not found"
              exit 1
            fi
            
            mv "$FOUND_FILE" emails.txt
            rm -rf "$CONTENT_ID"
            
            echo "Successfully downloaded emails.txt from GoFile"
          else
            echo "Using emails.txt from repository"
          fi
      
      - name: Verify emails.txt exists
        run: |
          if [ ! -f emails.txt ]; then
            echo "ERROR: emails.txt not found!"
            if [ "${{ inputs.email_source }}" = "Use emails.txt from repo" ]; then
              echo "Please add emails.txt to your repository."
            elif [ "${{ inputs.email_source }}" = "Download from URL" ]; then
              echo "Failed to download from URL: ${{ inputs.email_url }}"
            else
              echo "Failed to download from GoFile: ${{ inputs.gofile_url }}"
            fi
            exit 1
          fi
          echo "Found emails.txt with $(wc -l < emails.txt) lines"
      
      - name: Run Hotmail Checker
        run: |
          # Build command with options
          CMD="python go.py --auto"
          
          if [ "${{ inputs.filter_emails }}" = "true" ]; then
            CMD="$CMD --filter"
          fi
          
          if [ -n "${{ inputs.keyword }}" ]; then
            CMD="$CMD --keyword ${{ inputs.keyword }}"
          fi
          
          if [ "${{ inputs.threads }}" != "200" ]; then
            CMD="$CMD --threads ${{ inputs.threads }}"
          fi
          
          if [ "${{ inputs.enable_gofile }}" = "true" ]; then
            CMD="$CMD --gofile --interval ${{ inputs.backup_interval }}"
          fi
          
          echo "Running: $CMD"
          $CMD
      
      - name: Upload results as artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: hotmail-results-${{ inputs.keyword || 'default' }}
          path: |
            available*.txt
            taken*.txt
            failed*.txt
          retention-days: 30

  run-selenium-checker:
    if: inputs.script_type == 'Selenium Checker (Browser)'
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      
      - name: Install Chrome and dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y chromium-browser chromium-chromedriver
      
      - name: Install Python dependencies
        run: |
          pip install requests selenium webdriver-manager requests-toolbelt tqdm
      
      - name: Setup emails.txt
        run: |
          if [ "${{ inputs.email_source }}" = "Download from URL" ]; then
            if [ -z "${{ inputs.email_url }}" ]; then
              echo "ERROR: Email URL is required when 'Download from URL' is selected!"
              exit 1
            fi
            echo "Downloading emails.txt from: ${{ inputs.email_url }}"
            curl -L -o emails.txt "${{ inputs.email_url }}"
            if [ $? -ne 0 ]; then
              echo "ERROR: Failed to download emails.txt from URL!"
              exit 1
            fi
            echo "Successfully downloaded emails.txt"
          else
            echo "Using emails.txt from repository"
          fi
      
      - name: Setup emails.txt
        run: |
          if [ "${{ inputs.email_source }}" = "Download from URL" ]; then
            if [ -z "${{ inputs.email_url }}" ]; then
              echo "ERROR: Email URL is required when 'Download from URL' is selected!"
              exit 1
            fi
            echo "Downloading emails.txt from: ${{ inputs.email_url }}"
            curl -L -o emails.txt "${{ inputs.email_url }}"
            if [ $? -ne 0 ]; then
              echo "ERROR: Failed to download emails.txt from URL!"
              exit 1
            fi
            echo "Successfully downloaded emails.txt"
          elif [ "${{ inputs.email_source }}" = "Download from GoFile" ]; then
            if [ -z "${{ inputs.gofile_url }}" ]; then
              echo "ERROR: GoFile URL is required when 'Download from GoFile' is selected!"
              exit 1
            fi
            echo "Downloading emails.txt from GoFile: ${{ inputs.gofile_url }}"
            
            # Create inline GoFile downloader
            python3 - "${{ inputs.gofile_url }}" "${{ inputs.gofile_password }}" << 'GOFILE_SCRIPT'
          from os import getcwd, makedirs, path
          from sys import exit, stdout, argv
          from requests import Session
          
          class GoFileDownloader:
              def __init__(self, url: str, password: str = ""):
                  self._session = Session()
                  self._headers = {"User-Agent": "Mozilla/5.0", "Accept": "*/*"}
                  self._url = url
                  self._password = password
                  
              def _get_response(self, **kwargs):
                  for _ in range(3):
                      try:
                          return self._session.get(timeout=15, **kwargs)
                      except:
                          continue
              
              def _set_token(self):
                  try:
                      resp = self._session.post("https://api.gofile.io/accounts", headers=self._headers, timeout=15).json()
                      token = resp['data']['token']
                      self._headers["Cookie"] = f"accountToken={token}"
                      self._headers["Authorization"] = f"Bearer {token}"
                  except:
                      exit(1)
              
              def _download_file(self, url: str, filepath: str):
                  resp = self._get_response(url=url, headers=self._headers, stream=True)
                  if resp:
                      with open(filepath, 'wb') as f:
                          for chunk in resp.iter_content(8192):
                              f.write(chunk)
                      stdout.write(f"Downloaded: {filepath}\n")
              
              def _fetch_content(self, parent_dir: str, content_id: str):
                  url = f"https://api.gofile.io/contents/{content_id}?wt=4fd6sg89d7s6&cache=true"
                  if self._password:
                      from hashlib import sha256
                      url += f"&password={sha256(self._password.encode()).hexdigest()}"
                  
                  resp = self._get_response(url=url, headers=self._headers)
                  if not resp:
                      exit(1)
                  
                  data = resp.json()["data"]
                  
                  if data["type"] != "folder":
                      self._download_file(data["link"], path.join(parent_dir, data["name"]))
                      return
                  
                  folder = path.join(parent_dir, data["name"]) if path.basename(parent_dir) != content_id else parent_dir
                  makedirs(folder, exist_ok=True)
                  
                  for child in data["children"].values():
                      if child["type"] == "folder":
                          self._fetch_content(folder, child["id"])
                      else:
                          self._download_file(child["link"], path.join(folder, child["name"]))
              
              def run(self):
                  content_id = self._url.split("/")[-1]
                  stdout.write("Downloading from GoFile...\n")
                  self._set_token()
                  self._fetch_content(getcwd(), content_id)
                  stdout.write("Complete!\n")
          
          if __name__ == "__main__":
              GoFileDownloader(argv[1], argv[2] if len(argv) > 2 and argv[2] else "").run()
          GOFILE_SCRIPT
            
            # Find the downloaded file
            CONTENT_ID=$(echo "${{ inputs.gofile_url }}" | awk -F'/' '{print $NF}')
            FOUND_FILE=$(find "$CONTENT_ID" -name "emails.txt" -o -name "*.txt" 2>/dev/null | head -n 1)
            
            if [ -z "$FOUND_FILE" ]; then
              echo "ERROR: Could not find emails.txt in downloaded GoFile content!"
              ls -la "$CONTENT_ID" 2>/dev/null || echo "Content directory not found"
              exit 1
            fi
            
            mv "$FOUND_FILE" emails.txt
            rm -rf "$CONTENT_ID"
            
            echo "Successfully downloaded emails.txt from GoFile"
          else
            echo "Using emails.txt from repository"
          fi
      
      - name: Verify emails.txt exists
        run: |
          if [ ! -f emails.txt ]; then
            echo "ERROR: emails.txt not found!"
            if [ "${{ inputs.email_source }}" = "Use emails.txt from repo" ]; then
              echo "Please add emails.txt to your repository."
            elif [ "${{ inputs.email_source }}" = "Download from URL" ]; then
              echo "Failed to download from URL: ${{ inputs.email_url }}"
            else
              echo "Failed to download from GoFile: ${{ inputs.gofile_url }}"
            fi
            exit 1
          fi
          echo "Found emails.txt with $(wc -l < emails.txt) lines"
      
      - name: Configure Selenium script
        run: |
          # Update script configuration
          if [ -n "${{ inputs.keyword }}" ]; then
            echo "Setting keyword: ${{ inputs.keyword }}"
          fi
          
          if [ "${{ inputs.selenium_url }}" != "https://signup.live.com/signup" ]; then
            sed -i 's|TARGET_URL = .*|TARGET_URL = "${{ inputs.selenium_url }}"|' j.py
          fi
          
          if [ "${{ inputs.headless_mode }}" = "true" ]; then
            sed -i 's|# chrome_options.add_argument("--headless")|chrome_options.add_argument("--headless")|' j.py
          fi
          
          sed -i 's|CONCURRENT_BROWSERS = .*|CONCURRENT_BROWSERS = ${{ inputs.threads }}|' j.py
          sed -i 's|MAX_RETRIES = .*|MAX_RETRIES = ${{ inputs.max_retries }}|' j.py
          sed -i 's|BACKUP_INTERVAL_HOURS = .*|BACKUP_INTERVAL_HOURS = ${{ inputs.backup_interval }}|' j.py
      
      - name: Run Selenium Checker
        run: |
          python j.py
      
      - name: Upload results as artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: selenium-results-${{ inputs.keyword || 'default' }}
          path: |
            available.txt
            taken.txt
            failed.txt
          retention-days: 30
      
      - name: Upload screenshots (if any)
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: selenium-screenshots-${{ inputs.keyword || 'default' }}
          path: |
            *.png
          retention-days: 7
          if-no-files-found: ignore

  # Optional: Schedule job to run automatically
  # Uncomment the schedule section at the top to enable
  
  # Example scheduled run (runs every 6 hours)
  # schedule:
  #   - cron: '0 */6 * * *'
