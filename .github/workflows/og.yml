name: Email Checker Workflows (Windows)

on:
  workflow_dispatch:
    inputs:
      script_type:
        description: 'Which script to run?'
        required: true
        type: choice
        options:
          - 'Hotmail Checker (Fast API)'
          - 'Selenium Checker (Browser)'
        default: 'Hotmail Checker (Fast API)'
      
      # Email Source Options
      email_source:
        description: 'Email source'
        required: true
        type: choice
        options:
          - 'Use emails.txt from repo'
          - 'Download from URL'
          - 'Download from GoFile'
        default: 'Use emails.txt from repo'
      
      email_url:
        description: 'URL to download emails.txt from (if "Download from URL" selected)'
        required: false
        type: string
        default: ''
      
      gofile_url:
        description: 'GoFile URL (if "Download from GoFile" selected)'
        required: false
        type: string
        default: ''
      
      gofile_password:
        description: 'GoFile password (if required)'
        required: false
        type: string
        default: ''
      
      # Common Options
      keyword:
        description: 'Keyword for output filenames (optional)'
        required: false
        type: string
        default: ''
      
      threads:
        description: 'Number of threads (Hotmail) or browsers (Selenium)'
        required: false
        type: number
        default: 200
      
      filter_emails:
        description: 'Filter for @hotmail.com only?'
        required: false
        type: boolean
        default: false
      
      enable_gofile:
        description: 'Enable GoFile auto-backup?'
        required: false
        type: boolean
        default: true
      
      backup_interval:
        description: 'Backup interval in hours'
        required: false
        type: number
        default: 1.0
      
      # Selenium Specific Options
      selenium_url:
        description: '[Selenium] Target URL (default: Microsoft signup)'
        required: false
        type: string
        default: 'https://signup.live.com/signup'
      
      headless_mode:
        description: '[Selenium] Run browser in headless mode?'
        required: false
        type: boolean
        default: true
      
      max_retries:
        description: '[Selenium] Max retries per email'
        required: false
        type: number
        default: 2

jobs:
  run-hotmail-checker:
    if: inputs.script_type == 'Hotmail Checker (Fast API)'
    runs-on: windows-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      
      - name: Install dependencies
        run: |
          pip install requests termcolor urllib3 requests-toolbelt
      
      - name: Setup emails.txt
        shell: pwsh
        env:
          EMAIL_SOURCE: ${{ inputs.email_source }}
          EMAIL_URL: ${{ inputs.email_url }}
          GOFILE_URL: ${{ inputs.gofile_url }}
          GOFILE_PASS: ${{ inputs.gofile_password }}
        run: |
          if ($env:EMAIL_SOURCE -eq "Download from URL") {
            if (-not $env:EMAIL_URL) {
              Write-Error "ERROR: Email URL is required when 'Download from URL' is selected!"
              exit 1
            }
            Write-Host "Downloading emails.txt from: $env:EMAIL_URL"
            try {
              Invoke-WebRequest -Uri $env:EMAIL_URL -OutFile "emails.txt"
              Write-Host "Successfully downloaded emails.txt"
            } catch {
              Write-Error "ERROR: Failed to download emails.txt from URL!"
              exit 1
            }
          }
          elseif ($env:EMAIL_SOURCE -eq "Download from GoFile") {
            if (-not $env:GOFILE_URL) {
              Write-Error "ERROR: GoFile URL is required when 'Download from GoFile' is selected!"
              exit 1
            }
            Write-Host "Downloading emails.txt from GoFile: $env:GOFILE_URL"
            
            # Write Python script to file to avoid stdin issues on Windows
            $pyScript = @"
          from os import getcwd, makedirs, path
          from sys import exit, stdout, stderr, argv
          from requests import Session, Response, Timeout
          from typing import Any, TextIO, NoReturn
          from shutil import move

          def _print(msg: str) -> None:
              stdout.write(msg)
              stdout.flush()

          class GoFileDownloader:
              def __init__(self, url: str, password: str = ""):
                  self._session = Session()
                  self._headers = {"User-Agent": "Mozilla/5.0", "Accept": "*/*"}
                  self._url = url
                  self._password = password

              def _get_response(self, **kwargs):
                  for _ in range(3):
                      try:
                          return self._session.get(timeout=15, **kwargs)
                      except:
                          continue

              def _set_token(self):
                  try:
                      resp = self._session.post("https://api.gofile.io/accounts", headers=self._headers, timeout=15).json()
                      token = resp['data']['token']
                      self._headers["Cookie"] = f"accountToken={token}"
                      self._headers["Authorization"] = f"Bearer {token}"
                  except:
                      exit(1)

              def _download_file(self, url: str, filepath: str):
                  resp = self._get_response(url=url, headers=self._headers, stream=True)
                  if resp:
                      with open(filepath, 'wb') as f:
                          for chunk in resp.iter_content(8192):
                              f.write(chunk)
                      _print(f"Downloaded: {filepath}\n")

              def _fetch_content(self, parent_dir: str, content_id: str):
                  url = f"https://api.gofile.io/contents/{content_id}?wt=4fd6sg89d7s6&cache=true"
                  if self._password:
                      from hashlib import sha256
                      url += f"&password={sha256(self._password.encode()).hexdigest()}"

                  resp = self._get_response(url=url, headers=self._headers)
                  if not resp:
                      exit(1)

                  data = resp.json()["data"]

                  if data["type"] != "folder":
                      self._download_file(data["link"], path.join(parent_dir, data["name"]))
                      return

                  folder = path.join(parent_dir, data["name"]) if path.basename(parent_dir) != content_id else parent_dir
                  makedirs(folder, exist_ok=True)

                  for child in data["children"].values():
                      if child["type"] == "folder":
                          self._fetch_content(folder, child["id"])
                      else:
                          self._download_file(child["link"], path.join(folder, child["name"]))

              def run(self):
                  content_id = self._url.split("/")[-1]
                  _print("Downloading from GoFile...\n")
                  self._set_token()
                  self._fetch_content(getcwd(), content_id)
                  _print("Complete!\n")

          if __name__ == "__main__":
              GoFileDownloader(argv[1], argv[2] if len(argv) > 2 and argv[2] else "").run()
          "@
            Set-Content -Path "gofile_downloader.py" -Value $pyScript -Encoding UTF8
            
            # Run the python downloader
            python gofile_downloader.py "$env:GOFILE_URL" "$env:GOFILE_PASS"
            
            # Find the downloaded file using PowerShell
            $contentId = $env:GOFILE_URL.Split('/')[-1]
            $foundFile = Get-ChildItem -Path $contentId -Recurse -Filter "emails.txt" -ErrorAction SilentlyContinue | Select-Object -First 1
            if (-not $foundFile) {
               $foundFile = Get-ChildItem -Path $contentId -Recurse -Filter "*.txt" -ErrorAction SilentlyContinue | Select-Object -First 1
            }

            if (-not $foundFile) {
              Write-Error "ERROR: Could not find emails.txt in downloaded GoFile content!"
              exit 1
            }
            
            Move-Item -Path $foundFile.FullName -Destination "emails.txt" -Force
            Remove-Item -Path $contentId -Recurse -Force
            
            Write-Host "Successfully downloaded emails.txt from GoFile"
          }
          else {
            Write-Host "Using emails.txt from repository"
          }
      
      - name: Verify emails.txt exists
        shell: pwsh
        run: |
          if (-not (Test-Path "emails.txt")) {
            Write-Error "ERROR: emails.txt not found!"
            exit 1
          }
          # Changed to file size check to prevent hanging on large files
          $fileInfo = Get-Item "emails.txt"
          $sizeMb = $fileInfo.Length / 1MB
          Write-Host "Found emails.txt with size: $("{0:N2}" -f $sizeMb) MB"
      
      - name: Run Hotmail Checker
        shell: pwsh
        env:
          KEYWORD: ${{ inputs.keyword }}
          THREADS: ${{ inputs.threads }}
          FILTER: ${{ inputs.filter_emails }}
          GOFILE: ${{ inputs.enable_gofile }}
          INTERVAL: ${{ inputs.backup_interval }}
        run: |
          $cmdArgs = @("go.py", "--auto")
          
          if ($env:FILTER -eq 'true') { $cmdArgs += "--filter" }
          if ($env:KEYWORD) { $cmdArgs += "--keyword", $env:KEYWORD }
          if ($env:THREADS -ne '200') { $cmdArgs += "--threads", $env:THREADS }
          if ($env:GOFILE -eq 'true') { $cmdArgs += "--gofile", "--interval", $env:INTERVAL }
          
          Write-Host "Running: python $cmdArgs"
          python $cmdArgs
      
      - name: Upload results as artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: hotmail-results-${{ inputs.keyword || 'default' }}
          path: |
            available*.txt
            taken*.txt
            failed*.txt
          retention-days: 30

  run-selenium-checker:
    if: inputs.script_type == 'Selenium Checker (Browser)'
    runs-on: windows-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      
      # Windows runners usually include Chrome. 
      # We rely on webdriver-manager in python requirements to handle the driver.
      
      - name: Install Python dependencies
        run: |
          pip install requests selenium webdriver-manager requests-toolbelt tqdm
      
      - name: Setup emails.txt
        shell: pwsh
        env:
          EMAIL_SOURCE: ${{ inputs.email_source }}
          EMAIL_URL: ${{ inputs.email_url }}
          GOFILE_URL: ${{ inputs.gofile_url }}
          GOFILE_PASS: ${{ inputs.gofile_password }}
        run: |
          if ($env:EMAIL_SOURCE -eq "Download from URL") {
            if (-not $env:EMAIL_URL) {
              Write-Error "ERROR: Email URL is required when 'Download from URL' is selected!"
              exit 1
            }
            Write-Host "Downloading emails.txt from: $env:EMAIL_URL"
            try {
              Invoke-WebRequest -Uri $env:EMAIL_URL -OutFile "emails.txt"
            } catch {
              Write-Error "ERROR: Failed to download emails.txt from URL!"
              exit 1
            }
          }
          elseif ($env:EMAIL_SOURCE -eq "Download from GoFile") {
            if (-not $env:GOFILE_URL) {
              Write-Error "ERROR: GoFile URL is required when 'Download from GoFile' is selected!"
              exit 1
            }
            Write-Host "Downloading emails.txt from GoFile: $env:GOFILE_URL"
            
            # Write Python script to file to avoid stdin issues on Windows
            $pyScript = @"
          from os import getcwd, makedirs, path
          from sys import exit, stdout, stderr, argv
          from requests import Session, Response, Timeout
          from typing import Any, TextIO, NoReturn
          from shutil import move

          def _print(msg: str) -> None:
              stdout.write(msg)
              stdout.flush()

          class GoFileDownloader:
              def __init__(self, url: str, password: str = ""):
                  self._session = Session()
                  self._headers = {"User-Agent": "Mozilla/5.0", "Accept": "*/*"}
                  self._url = url
                  self._password = password

              def _get_response(self, **kwargs):
                  for _ in range(3):
                      try:
                          return self._session.get(timeout=15, **kwargs)
                      except:
                          continue

              def _set_token(self):
                  try:
                      resp = self._session.post("https://api.gofile.io/accounts", headers=self._headers, timeout=15).json()
                      token = resp['data']['token']
                      self._headers["Cookie"] = f"accountToken={token}"
                      self._headers["Authorization"] = f"Bearer {token}"
                  except:
                      exit(1)

              def _download_file(self, url: str, filepath: str):
                  resp = self._get_response(url=url, headers=self._headers, stream=True)
                  if resp:
                      with open(filepath, 'wb') as f:
                          for chunk in resp.iter_content(8192):
                              f.write(chunk)
                      _print(f"Downloaded: {filepath}\n")

              def _fetch_content(self, parent_dir: str, content_id: str):
                  url = f"https://api.gofile.io/contents/{content_id}?wt=4fd6sg89d7s6&cache=true"
                  if self._password:
                      from hashlib import sha256
                      url += f"&password={sha256(self._password.encode()).hexdigest()}"

                  resp = self._get_response(url=url, headers=self._headers)
                  if not resp:
                      exit(1)

                  data = resp.json()["data"]

                  if data["type"] != "folder":
                      self._download_file(data["link"], path.join(parent_dir, data["name"]))
                      return

                  folder = path.join(parent_dir, data["name"]) if path.basename(parent_dir) != content_id else parent_dir
                  makedirs(folder, exist_ok=True)

                  for child in data["children"].values():
                      if child["type"] == "folder":
                          self._fetch_content(folder, child["id"])
                      else:
                          self._download_file(child["link"], path.join(folder, child["name"]))

              def run(self):
                  content_id = self._url.split("/")[-1]
                  _print("Downloading from GoFile...\n")
                  self._set_token()
                  self._fetch_content(getcwd(), content_id)
                  _print("Complete!\n")

          if __name__ == "__main__":
              GoFileDownloader(argv[1], argv[2] if len(argv) > 2 and argv[2] else "").run()
          "@
            Set-Content -Path "gofile_downloader.py" -Value $pyScript -Encoding UTF8
            
            # Run the python downloader
            python gofile_downloader.py "$env:GOFILE_URL" "$env:GOFILE_PASS"
            
            # Find the downloaded file using PowerShell
            $contentId = $env:GOFILE_URL.Split('/')[-1]
            $foundFile = Get-ChildItem -Path $contentId -Recurse -Filter "emails.txt" -ErrorAction SilentlyContinue | Select-Object -First 1
            if (-not $foundFile) {
               $foundFile = Get-ChildItem -Path $contentId -Recurse -Filter "*.txt" -ErrorAction SilentlyContinue | Select-Object -First 1
            }

            if (-not $foundFile) {
              Write-Error "ERROR: Could not find emails.txt in downloaded GoFile content!"
              exit 1
            }
            
            Move-Item -Path $foundFile.FullName -Destination "emails.txt" -Force
            Remove-Item -Path $contentId -Recurse -Force
            
            Write-Host "Successfully downloaded emails.txt from GoFile"
          }
          else {
            Write-Host "Using emails.txt from repository"
          }
          
          # Re-verification for Selenium job
          if (-not (Test-Path "emails.txt") -and $env:EMAIL_SOURCE -ne "Download from GoFile") {
             # If not gofile (which needs the script), and file missing:
             if ($env:EMAIL_SOURCE -eq "Use emails.txt from repo") {
                 Write-Error "emails.txt not found in repo"
                 exit 1
             }
          }

      - name: Verify emails.txt exists
        shell: pwsh
        run: |
          if (-not (Test-Path "emails.txt")) {
            Write-Error "ERROR: emails.txt not found!"
            exit 1
          }
          # Changed to file size check to prevent hanging on large files
          $fileInfo = Get-Item "emails.txt"
          $sizeMb = $fileInfo.Length / 1MB
          Write-Host "Found emails.txt with size: $("{0:N2}" -f $sizeMb) MB"

      - name: Configure Selenium script
        shell: pwsh
        env:
          KEYWORD: ${{ inputs.keyword }}
          SELENIUM_URL: ${{ inputs.selenium_url }}
          HEADLESS: ${{ inputs.headless_mode }}
          THREADS: ${{ inputs.threads }}
          RETRIES: ${{ inputs.max_retries }}
          INTERVAL: ${{ inputs.backup_interval }}
        run: |
          $file = "j.py"
          $content = Get-Content $file -Raw
          
          if ($env:KEYWORD) { Write-Host "Setting keyword: $env:KEYWORD" }
          
          # PowerShell String Replacement instead of SED
          if ($env:SELENIUM_URL -ne "https://signup.live.com/signup") {
             $content = $content -replace 'TARGET_URL = .*', "TARGET_URL = `"$env:SELENIUM_URL`""
          }
          
          if ($env:HEADLESS -eq 'true') {
             $content = $content -replace '# chrome_options.add_argument\("--headless"\)', 'chrome_options.add_argument("--headless")'
          }
          
          $content = $content -replace 'CONCURRENT_BROWSERS = .*', "CONCURRENT_BROWSERS = $env:THREADS"
          $content = $content -replace 'MAX_RETRIES = .*', "MAX_RETRIES = $env:RETRIES"
          $content = $content -replace 'BACKUP_INTERVAL_HOURS = .*', "BACKUP_INTERVAL_HOURS = $env:INTERVAL"
          
          Set-Content -Path $file -Value $content
      
      - name: Run Selenium Checker
        run: |
          python j.py
      
      - name: Upload results as artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: selenium-results-${{ inputs.keyword || 'default' }}
          path: |
            available.txt
            taken.txt
            failed.txt
          retention-days: 30
      
      - name: Upload screenshots (if any)
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: selenium-screenshots-${{ inputs.keyword || 'default' }}
          path: |
            *.png
          retention-days: 7
          if-no-files-found: ignore
